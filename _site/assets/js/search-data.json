{"0": {
    "doc": "Filesystem",
    "title": "Table of contents",
    "content": ". | Hello File | Resource Handling | Buffered I/O | . ",
    "url": "http://localhost:4000/docs/Z-IO/Filesystem.html#table-of-contents",
    "relUrl": "/Z-IO/Filesystem.html#table-of-contents"
  },"1": {
    "doc": "Filesystem",
    "title": "Hello File",
    "content": "It’s easy to use Z-IO package’s filesystem module, first please import Z.IO.Filesystem: . import qualified Z.IO.FileSystem as FS . If it’s OK to load a file into memory at once, you can use following: . readFile :: HasCallStack =&gt; CBytes -&gt; IO Bytes readTextFile :: HasCallStack =&gt; CBytes -&gt; IO Text writeFile :: HasCallStack =&gt; CBytes -&gt; Bytes -&gt; IO () writeTextFile :: HasCallStack =&gt; CBytes -&gt; Text -&gt; IO () . CBytes is Z’s file path type, Bytes, Text are binary and textual content type respectively, which all be document in Z-Data section. For now, all you need to know is Z-IO assumes UTF-8 encoding everywhere: both filepath and text content are assumed using UTF-8 encoding. &gt; FS.writeTextFile \"./test_file\" \"hello world!\" &gt; FS.readFile \"./test_file\" [104,101,108,108,111,32,119,111,114,108,100,33] &gt; FS.readTextFile \"./test_file\" \"hello world!\" . ",
    "url": "http://localhost:4000/docs/Z-IO/Filesystem.html#hello-file",
    "relUrl": "/Z-IO/Filesystem.html#hello-file"
  },"2": {
    "doc": "Filesystem",
    "title": "Resource Handling",
    "content": "Now let’s see a more complicated function: . initFile :: CBytes -&gt; FileFlag -- ^ Opening flags, e.g. 'O_CREAT' @.|.@ 'O_RDWR' -&gt; FileMode -- ^ Sets the file mode (permission and sticky bits), -- but only if the file was created, see 'DEFAULT_FILE_MODE'. -&gt; Resource File . FileFlag and FileMode are bit constants controlling the file opening behavior, e.g. if we have read or write access, or if a new file will be created if there’s none. You can find more constants on hacakge’s document. What’s interesting here is that initFile function return a Resource File type instead of IO File. Resource is defined in Z.IO.Resource module, with a function to use it: . withResource :: HasCallStack =&gt; Resource a -- ^ resource management record -&gt; (a -&gt; IO b) -- ^ function working on a resource -&gt; IO b . We simplified those two functions’ type a little bit, and here is the idea: withResource will take care about resource opening and cleanup automatically, after you finish using it, or when exception happens. You only need to pass a function working on that resource. Now let’s read the file created above again: . import Z.IO -- this module re-export Z.IO.Resource and other common stuff import qualified Z.IO.FileSystem as FS withResource (FS.initFile \"./test_file\" FS.O_RDWR FS.DEFAULT_FILE_MODE) $ \\ file -&gt; do bi &lt;- newBufferedInput file printStd =&lt;&lt; readLine bi . initFile function doesn’t open the file, it just record how to open and close the file. Everytime you want to do something about the file, use withResource to open(and close) it, and that’s all about resource handling in Z. ",
    "url": "http://localhost:4000/docs/Z-IO/Filesystem.html#resource-handling",
    "relUrl": "/Z-IO/Filesystem.html#resource-handling"
  },"3": {
    "doc": "Filesystem",
    "title": "Buffered I/O",
    "content": "newBufferedInput and readLine functions in the code above are from Z.IO.Buffered module(also re-exported from Z.IO). In Z-IO, many IO devices(including File above) are instances to Input/Output class: . class Input i where readInput :: HasCallStack =&gt; i -&gt; Ptr Word8 -&gt; Int -&gt; IO Int class Output o where writeOutput :: HasCallStack =&gt; o -&gt; Ptr Word8 -&gt; Int -&gt; IO () . readInput and writeOutput works on pointers, which is not very convenient for directly usage. Open a BufferedInput or BufferedOutput to get auto managed buffered I/O: . newBufferedInput :: Input i =&gt; i -&gt; IO BufferedInput newBufferedOutput :: Output i =&gt; i -&gt; IO BufferedOutput . There’s a set of functions working on BufferedInput/BufferedOutput in Z.IO.Buffered, for example to implement a word counter for files: . import Z.IO import qualified Z.IO.FileSystem as FS import qualified Z.Data.Vector as V main :: IO () main = do -- get file path from command line (_:path:_) &lt;- getArgs withResource (FS.initFile path FS.O_RDWR FS.DEFAULT_FILE_MODE) $ \\ file -&gt; do bi &lt;- newBufferedInput file printStd =&lt;&lt; loop bi 0 where loop :: BufferedInput -&gt; Int -&gt; IO Int loop input !wc = do -- read a single line without linefeed dropped line &lt;- readLine input case line of Just line' -&gt; loop input (wc + length (V.words line')) _ -&gt; return wc . ",
    "url": "http://localhost:4000/docs/Z-IO/Filesystem.html#buffered-io",
    "relUrl": "/Z-IO/Filesystem.html#buffered-io"
  },"4": {
    "doc": "Filesystem",
    "title": "Filesystem",
    "content": " ",
    "url": "http://localhost:4000/docs/Z-IO/Filesystem.html",
    "relUrl": "/Z-IO/Filesystem.html"
  },"5": {
    "doc": "Vector and Array",
    "title": "Array",
    "content": " ",
    "url": "http://localhost:4000/docs/Z-Data/VectorAndArray.html#array",
    "relUrl": "/Z-Data/VectorAndArray.html#array"
  },"6": {
    "doc": "Vector and Array",
    "title": "Vector and Array",
    "content": " ",
    "url": "http://localhost:4000/docs/Z-Data/VectorAndArray.html",
    "relUrl": "/Z-Data/VectorAndArray.html"
  },"7": {
    "doc": "Benchmarks",
    "title": "Table of contents",
    "content": ". | JSON performance | TCP performance | . Benchmarks’ code are available on Github. Note benchmarks only record certain aspect of the code and the setup environment, they may not reflect real-world use-case. Any patches to improve the simulation as practical as possible are welcomed. ",
    "url": "http://localhost:4000/docs/benchmarks.html#table-of-contents",
    "relUrl": "/benchmarks.html#table-of-contents"
  },"8": {
    "doc": "Benchmarks",
    "title": "JSON performance",
    "content": "This benchmark compared JSON module in Z-Data with aeson, a widely used JSON package on hackage. See our analysis in this blog post. ",
    "url": "http://localhost:4000/docs/benchmarks.html#json-performance",
    "relUrl": "/benchmarks.html#json-performance"
  },"9": {
    "doc": "Benchmarks",
    "title": "TCP performance",
    "content": "This benchmark compared different redis PING-PONG server implementations, using redis-benchmark tool from redis package running redis-benchmark -p 8888 -t ping -n 100000 -q -c 100. # Haskell's network package # cabal run redis-benchmark-base -- +RTS -N4 -H2G PING_INLINE: 88105.73 requests per second PING_BULK: 87873.46 requests per second # Z-IO from Z.Haskell # cabal run redis-benchmark-z -- +RTS -N4 -H2G PING_INLINE: 99800.40 requests per second PING_BULK: 102459.02 requests per second # Golang standard lib PING_INLINE: 98716.68 requests per second PING_BULK: 101522.84 requests per second # Rust mio PING_INLINE: 111731.84 requests per second PING_BULK: 112612.61 requests per second # C libuv PING_INLINE: 109170.30 requests per second PING_BULK: 105374.08 requests per second . Note both mio and libuv using a single thread event loop and a shared buffer to receive redis-benchmark’s messages between different connection, which is quite different from other lightweight thread based implementations. GHC also provides memory statistics: . # Haskell's network package # cabal run redis-benchmark-base -- +RTS -N4 -s -H2G 3,751,313,096 bytes allocated in the heap 302,793,568 bytes copied during GC 1,869,864 bytes maximum residency (1044 sample(s)) 490,016 bytes maximum slop 2085 MiB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 2085 colls, 2085 par 0.455s 0.131s 0.0001s 0.0085s Gen 1 1044 colls, 1043 par 0.419s 0.149s 0.0001s 0.0226s Parallel GC work balance: 82.10% (serial 0%, perfect 100%) TASKS: 10 (1 bound, 9 peak workers (9 total), using -N4) SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled) INIT time 0.001s ( 0.001s elapsed) MUT time 5.360s ( 5.842s elapsed) GC time 0.874s ( 0.280s elapsed) EXIT time 0.001s ( 0.008s elapsed) Total time 6.236s ( 6.130s elapsed) Alloc rate 699,915,737 bytes per MUT second Productivity 85.9% of total user, 95.3% of total elapsed # Z-IO from Z.Haskell # cabal run redis-benchmark-z -- +RTS -N4 -s -H2G 280,828,448 bytes allocated in the heap 835,688 bytes copied during GC 3,375,112 bytes maximum residency (4 sample(s)) 839,672 bytes maximum slop 2084 MiB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 5 colls, 5 par 0.009s 0.008s 0.0015s 0.0073s Gen 1 4 colls, 3 par 0.023s 0.021s 0.0052s 0.0194s Parallel GC work balance: 82.81% (serial 0%, perfect 100%) TASKS: 14 (1 bound, 13 peak workers (13 total), using -N4) SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled) INIT time 0.001s ( 0.001s elapsed) MUT time 2.811s ( 6.757s elapsed) GC time 0.032s ( 0.028s elapsed) EXIT time 0.002s ( 0.004s elapsed) Total time 2.846s ( 6.790s elapsed) Alloc rate 99,903,441 bytes per MUT second Productivity 98.8% of total user, 99.5% of total elapsed . ",
    "url": "http://localhost:4000/docs/benchmarks.html#tcp-performance",
    "relUrl": "/benchmarks.html#tcp-performance"
  },"10": {
    "doc": "Benchmarks",
    "title": "Benchmarks",
    "content": " ",
    "url": "http://localhost:4000/docs/benchmarks.html",
    "relUrl": "/benchmarks.html"
  },"11": {
    "doc": "Blog",
    "title": "High-performance JSON codec",
    "content": "2021-02-02 06:52:44 +0800 by Dong . JSON processing is a fundamental building block in modern network applications. It’s also a large module in Z-Data package. With careful optimization, we managed to get a 1.5X - 3X encoding and 3X decoding performance boost comparing to aeson, a widely used JSON package on hackage. | . ",
    "url": "http://localhost:4000/docs/blog.html",
    "relUrl": "/blog.html"
  },"12": {
    "doc": "Blog",
    "title": "Blog",
    "content": ". | ",
    "url": "http://localhost:4000/docs/blog.html",
    "relUrl": "/blog.html"
  },"13": {
    "doc": "Guide",
    "title": "Table of contents",
    "content": ". | Requirements | Installation | . ",
    "url": "http://localhost:4000/docs/guide#table-of-contents",
    "relUrl": "/guide#table-of-contents"
  },"14": {
    "doc": "Guide",
    "title": "Requirements",
    "content": "You need a working haskell compiler system: GHC(&gt;=8.6), cabal-install(&gt;=2.4). You can download pre-built binaries(GHC, cabal-install) and install manually, or use package management on your operating system if available: . | Mac users can get them via homebew: brew install ghc cabal-install. | Windows users can get them via chocolatey: choco install ghc cabal. | Ubuntu users are recommended to use ppa. | . ",
    "url": "http://localhost:4000/docs/guide#requirements",
    "relUrl": "/guide#requirements"
  },"15": {
    "doc": "Guide",
    "title": "Installation",
    "content": "To use Z-IO package for example, add following lines to your project’s cabal file: ... build-depends: Z-IO == 0.1.* . Now run cabal build within your project directory, cabal should be able to download Z-IO dependency automatically. Let’s write a simple tcp echo server for example: . | Initialize a project with cabal. | . mkdir tcp-echo cd tcp-echo cabal init -i . Now cabal will ask you some simple questions about your project, then create a tcp-echo.cabal file automatically, which records the building configuration. | Add Z-IO and Z-Data to project’s cabal file. | . Now open tcp-echo.cabal file with a text editor, add following lines under executable section: ... build-depends: Z-IO == 0.5.* Z-Data == 0.5.* . | Edit Main.hs. | . Open src/Main.hs and add a simple echo tcp server: . You can check Z-Example for some example code. ",
    "url": "http://localhost:4000/docs/guide#installation",
    "relUrl": "/guide#installation"
  },"16": {
    "doc": "Guide",
    "title": "Guide",
    "content": " ",
    "url": "http://localhost:4000/docs/guide",
    "relUrl": "/guide"
  },"17": {
    "doc": "Z-Data",
    "title": "Z-Data",
    "content": ". | Z-Data . | Array, vector(array slice), Bytes(Word8 vectors) | Text based UTF-8, basic unicode manipulating | FFI utilties | Parsing and building monad | JSON encoding and decoding | . | . ",
    "url": "http://localhost:4000/docs/Z-Data/",
    "relUrl": "/Z-Data/"
  },"18": {
    "doc": "Z-IO",
    "title": "Z-IO",
    "content": "Z-IO package provides high-performance I/O operations based on libuv’s event loop and GHC lightweight threads. ",
    "url": "http://localhost:4000/docs/Z-IO/",
    "relUrl": "/Z-IO/"
  }
}
